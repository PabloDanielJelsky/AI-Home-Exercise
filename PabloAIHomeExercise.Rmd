---
title:    "Pablo AI home exercise"
author:   "Pablo Daniel Jelsky"
date:     "20/02/2021"
version:  0.01
output:   html_document
---

# **Exercise on target tracking**
## Links related to this exercise
-   [Digital Elevation Model (DEM)](https://en.wikipedia.org/wiki/Digital_elevation_model)
-   [Geospatial Data Abstraction Library (GDAL)](https://en.wikipedia.org/wiki/GDAL)
-   [GeoTIFF](https://en.wikipedia.org/wiki/GeoTIFF)

## Task objective: double tracking
-   The idea of this task is to create an algorithm that allows the continuous tracking after the person - "target" - by a couple of followers
-   Given a DSM (Digital Surface Model) building's map - 100 [m] x 100 [m] matrix ????
-   Given the "target" maximum speed as 1 meter/second in a not known in advance route. The "target movement is limited only to "ground" level
-   Given the "followers" speed as 2 meters/second, and are only allowed to be as close as 10 meters (no less than this) from the "target". The "followers" movement is also limited to "ground" level
-   The task objective is to create an algorithm that once in a second, gives us the "target" and "followers" position given the limitations above, and issues instructions to the "followers" next movement in order that at least one of the "followers" could have "eye-contact" as much as possible with the "target"


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Development steps

```{r Global variables}
# Clear the global work-space
rm (list = ls())
# Define new global variables
DSM_FILE                              = "cage6.tif"
TARGET_MAXIMUM_SPEED_IN_M_SEC         = 1
FOLLOWER_SPEED_IN_M_SEC               = 2
TARGET_FOLLOWER_MINIMUM_DISTANCE_M    = 10
DSM_LENGTH_M                          = 100


```


```{r R packages needed}
# knitr library - A general-purpose tool for dynamic report generation in R
suppressPackageStartupMessages(library(knitr))
# dplyr library - A grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges
suppressPackageStartupMessages(library(dplyr))                             
# ggplot2 library - A tool to create elegant data visualizations using the grammar of graphics
suppressPackageStartupMessages(library(ggplot2))
# A package providing classes and methods for spatial data: points, lines, polygons and grids, needed by raster library
suppressPackageStartupMessages(library(sp))
# library used to work with raster data
suppressPackageStartupMessages(library(raster))
# GDAL is a translator library for raster and vector geospatial data formats that is released under an X/MIT style Open Source License by the Open Source Geospatial Foundation. As a library, it presents a single raster abstract data model and single vector abstract data model to the calling application for all supported formats. 
# This library is the port to R of the GDAL library (to be used for GeoTIFFs and oher core GIS functions)
library(rgdal)

```


```{r Data importing}
# Set the working directory
setwd ("/home/pablo/Documents/Software Engineering/AI home exercise/Input/")

# view raster attributes
cage6Raster <- raster(DSM_FILE)
GDALinfo(DSM_FILE)
# Convert to matrix to start working
cage6Matrix <- getValues(cage6Raster, format = "matrix")
print(c("Number of rows of ", DSM_FILE, ":", nrow(cage6Matrix)))
print(c("Number of columns of ", DSM_FILE, ":", ncol(cage6Matrix)))


```


## Visual simulation

```{r}

# Show the DSM (Digital Surface Model) map in Python or Matlab (in this case in R)
spplot(cage6Raster)
# Target
## Create "target" route given beginning and ending location __GoFromAtoB(OriginalDSMFile, LocationA, LocationB, VisibilityInMeters)__

GoFromAtoB = function(OriginalDSMFile, LocationA, LocationB, VisibilityInMeters)
{
  return (NewDSMFileWithRouteFromAtoB)
}

## Show "target" progress over time in DSM map
# Followers
## Show "followers" progress over time in DSM map
# Line of sight (LOS)
## Show line of sight between the "follower" and the "target" if the LOS exists



```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

##    Help tools for the solution
###       Line of sight (LOS) map
-   Map for every pixel at "ground" level, all the pixels that are inside the LOS
-   Take a few locations in the DSM and show the results in it

##    Working with "only" one follower
-   Write a function that will return the progress command to the follower given his and the "target" current locations: __CalculateNextLocation(TargetCurrentLocation, FollowerCurrentLocation)__
-   Progress command will take in account the potential next location of both the "target" and the "follower" so that will have LOS between "follower" and "target" as much as possible time

```{r}



CalculateNextLocation = function(TargetCurrentLocation, FollowerCurrentLocation)
{
  return (FollowerNextLocation)
}

```


##    Working with a couple of followers - Central calculation
-   Like in the previous section, but the function should give guidance to both followers: __CalculateNextLocation2(TargetCurrentLocation, FollowerCurrentLocation)__
-   It is desirable that there will be some kind of coordination between both commands so that one follower will complement the other

```{r}

CalculateNextLocation2 = function(TargetCurrentLocation, FollowerCurrentLocation)
{
  return (FollowersNextLocation)
}

```


##    Working with a couple of followers - Distributed calculation
-   Write a function that will return the progress command to a __single__ follower given his, the second follower and the "target" current locations: __CalculateNextLocation3(TargetCurrentLocation, OtherFollowerCurrentLocation, FollowerCurrentLocation)__
-   The function (for each follower) are not related between them
-   The function will give guidance every 2 seconds, once the function will work with follower1, and the next second will work with follower2, therefore the function(s) won't work with the same input
-   It is desirable that there will be some kind of coordination between both commands so that one follower will complement the other


```{r}


CalculateNextLocation3 = function(TargetCurrentLocation, OtherFollowerCurrentLocation, FollowerCurrentLocation)
{
  return (FollowerNextLocation)
}


```



# __שאלות ליאיר__
-   המפה בפועך היא
 
  201x351 "pixels"
  
  אך כתוב במבחן שהמפה היא 

  100x100 m
  מה זה אומר ?
 
  שאנחנו לוקחים רק 
 
  100x100 פיקסלים ויוצאים בנהחה שכל פיקסל מטר אחד ?

-   מה רסולוציה מינימאלית בסימולציה ?
  מטר אחד ושנייה אחת ?
-   אם כך, בהנתן שמהירות המטרה היא עד 1 מטר לשנייה, מה זה אומר ? שהמטרה יכולה לא לזוז מפיקסל לפיקסל אם זה פחות ממטר לשנייה ?
-   כתוב שמהירות העוקבים היא 2 מטר לשנייה. יכולה להיות גם פחות או קבועה ב 2מטר לשנייה ?
-   נקודות התחלה של המטרה והעוקבים יהיו קבועות ?
-   לחישוב מסלול מטרה חשבתי על קו ראיה של המטרה ואם רואה חומה אז הוא מחליט ללכת מצד החומה

אם כך, האם לתת לו VISIBILITY.... כמה מטרים הוא יכול לראות ?




