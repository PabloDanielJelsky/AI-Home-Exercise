---
title:    "Pablo AI home exercise"
author:   "Pablo Daniel Jelsky"
date:     "22/02/2021"
version:  0.03
output:   html_document
---

# **Exercise on target tracking**
## Links related to this exercise
-   [Digital Elevation Model (DEM)](https://en.wikipedia.org/wiki/Digital_elevation_model)
-   [Geospatial Data Abstraction Library (GDAL)](https://en.wikipedia.org/wiki/GDAL)
-   [GeoTIFF](https://en.wikipedia.org/wiki/GeoTIFF)

## Task objective: double tracking
-   The idea of this task is to create an algorithm that allows the continuous tracking after the person - "target" - by a couple of followers
-   Given a DSM (Digital Surface Model) building's map - 100 [m] x 100 [m] matrix ????
-   Given the "target" maximum speed as 1 meter/second in a not known in advance route. The "target movement is limited only to "ground" level
-   Given the "followers" speed as 2 meters/second, and are only allowed to be as close as 10 meters (no less than this) from the "target". The "followers" movement is also limited to "ground" level
-   The task objective is to create an algorithm that once in a second, gives us the "target" and "followers" position given the limitations above, and issues instructions to the "followers" next movement in order that at least one of the "followers" could have "eye-contact" as much as possible with the "target"

## Clarifications from Yair email (2021-02-21)
-   Work with the DSM with the size 'as is' 351x201 pixels 
-   One pixel equals to one meter
-   The target is supposed to have constant rate (1 meter/second) and could NOT stop
-   The follower agent could also stop or up to 2 meters/second (0 meters/second, 1 meter/second, 2 meters/second)
-   Starting points for the target and follower agents could be in every place but NOT in a "obstacle" level (NOT "ground" level)
-   The agents will have LOS with the "target" in the first simulation cycle


```{r setup, include=FALSE}
# knitr library - A general-purpose tool for dynamic report generation in R
suppressPackageStartupMessages(library(knitr))

knitr::opts_chunk$set(echo = TRUE)
```

## Development steps

```{r Global variables}
# Clear the global work-space
rm (list = ls())
# Define global variables
ROOT_DIRECTORY                        = "/home/pablo/Documents/Software Engineering/AI home exercise/Input/"
DSM_FILE                              = "cage6.tif"
TARGET_SPEED_IN_M_SEC                 = 1
AGENT_SPEED_IN_M_SEC                  = 2
TARGET_AGENT_MINIMUM_DISTANCE_M       = 10




```


```{r R packages needed}

# dplyr library - A grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges
suppressPackageStartupMessages(library(dplyr))                             
# ggplot2 library - A tool to create elegant data visualizations using the grammar of graphics
suppressPackageStartupMessages(library(ggplot2))
library(viridis)
# A package providing classes and methods for spatial data: points, lines, polygons and grids, needed by raster library
suppressPackageStartupMessages(library(sp))
# library used to work with raster data
suppressPackageStartupMessages(library(raster))
# GDAL is a translator library for raster and vector geospatial data formats that is released under an X/MIT style Open Source License by the Open Source Geospatial Foundation. As a library, it presents a single raster abstract data model and single vector abstract data model to the calling application for all supported formats. 
# This library is the port to R of the GDAL library (to be used for GeoTIFFs and oTher core GIS functions)
library(rgdal)

```


```{r Data importing}

# Set the working directory
setwd (ROOT_DIRECTORY) #  because we are using knitr, then we need also the following solution
require("knitr")
opts_knit$set(root.dir = ROOT_DIRECTORY)

# view raster attributes
DsmOriginalRaster   <- raster(DSM_FILE)
GDALinfo(DSM_FILE)
# Convert to matrix to start working
DsmOriginalMatrix   <- getValues(DsmOriginalRaster, format = "matrix")
# Get useful variables
DsmNumberOfColumns  <- ncol(DsmOriginalMatrix)
DsmNumberOfRows     <- nrow(DsmOriginalMatrix)
sprintf("Info for %s DSM file: %d rows x %d columns", DSM_FILE, DsmNumberOfRows, DsmNumberOfColumns) 

```


## Visual simulation

### Useful links
-   [Finding Shortest Path in the Plane with Obstacles](https://www.codingame.com/playgrounds/39380/finding-shortest-path-in-the-plane-with-obstacles)
-   [A* Algorithm: How to find the shortest path between two points](https://medium.com/analytics-vidhya/a-algorithm-how-to-find-the-shortest-path-between-two-points-767c8a76376)
-   [Shortest distance between two cells in a matrix or grid](https://www.geeksforgeeks.org/shortest-distance-two-cells-matrix-grid/)

```{r}

# Show the DSM (Digital Surface Model) map in Python or Matlab (in this case in R)
spplot(DsmOriginalRaster)
# Target
## Create "target" route given beginning and ending location __GoFromAtoB(OriginalDSMFile, LocationA, LocationB, VisibilityInMeters)__

GoFromAtoB = function(OriginalDSMFile, LocationA, LocationB, VisibilityInMeters)
{
  return (NewDSMFileWithRouteFromAtoB)
}

## Show "target" progress over time in DSM map
TargetArrivedToDestination  <- FALSE
SimulationTimeInSeconds     <- 0
### Loop
while (TargetArrivedToDestination == FALSE) {

  if (SimulationTimeInSeconds >= 60) {
    TargetArrivedToDestination  <- TRUE
  }
  else {
    print(sprintf("Time %d    Target position (x,y)", SimulationTimeInSeconds))
    SimulationTimeInSeconds     <- SimulationTimeInSeconds + 1
  }
}

DsmTargetRasterLayerBuildings   <- DsmOriginalRaster
DsmTargetRasterLayerTarget      <- list("Target", c(180500,329900), "0")
plot(DsmTargetRasterLayerBuildings, main = "Target")

# turn the data into a spatial data frame 
#DsmTargetRasterLayerBuildings_df <- SpatialLinesDataFrame(DsmTargetRasterLayerBuildings) 
#tidy(coastlines_sim2_df)

## Convert it to a dataframe    
DsmTargetRasterLayerBuildings_df  <- as.data.frame(DsmTargetRasterLayerBuildings, xy = TRUE)
## Renaming columns
DsmTargetRasterLayerBuildings_df  <- setNames(DsmTargetRasterLayerBuildings_df, c("longitude", "latitude", "altitude"))
# Convert altitude to factor
#DsmTargetRasterLayerBuildings_df$altitude <- as.factor(DsmTargetRasterLayerBuildings_df$altitude)
#factor
#levels(DsmTargetRasterLayerBuildings_df$altitude)
# plot the data 
#ggplot() +
#  geom_path(data = DsmTargetRasterLayerBuildings_df, aes(x = longitude, y = latitude, color = altitude)) +
#  geom_point() +
#  labs(title = "Target"
plot <- ggplot(DsmTargetRasterLayerBuildings_df, aes(x = longitude, y = latitude, color = altitude))
plot <- plot + geom_point() + scale_color_viridis()
print (plot)
#  geom_path(data = DsmTargetRasterLayerBuildings_df, aes(x = long, y = lat, group = group)) +
#  labs(title = "Target")
# Followers
## Show "followers" progress over time in DSM map
# Line of sight (LOS)
## Show line of sight between the "follower" and the "target" if the LOS exists



```

##    Help tools for the solution
###       Line of sight (LOS) map
-   Map for every pixel at "ground" level, all the pixels that are inside the LOS
-   Take a few locations in the DSM and show the results in it

##    Working with "only" one follower
-   Write a function that will return the progress command to the follower given his and the "target" current locations: __CalculateNextLocation(TargetCurrentLocation, FollowerCurrentLocation)__
-   Progress command will take in account the potential next location of both the "target" and the "follower" so that will have LOS between "follower" and "target" as much as possible time

```{r}



CalculateNextLocation = function(TargetCurrentLocation, FollowerCurrentLocation)
{
  return (FollowerNextLocation)
}

```


##    Working with a couple of followers - Central calculation
-   Like in the previous section, but the function should give guidance to both followers: __CalculateNextLocation2(TargetCurrentLocation, FollowerCurrentLocation)__
-   It is desirable that there will be some kind of coordination between both commands so that one follower will complement the other

```{r}

CalculateNextLocation2 = function(TargetCurrentLocation, FollowerCurrentLocation)
{
  return (FollowersNextLocation)
}

```


##    Working with a couple of followers - Distributed calculation
-   Write a function that will return the progress command to a __single__ follower given his, the second follower and the "target" current locations: __CalculateNextLocation3(TargetCurrentLocation, OtherFollowerCurrentLocation, FollowerCurrentLocation)__
-   The function (for each follower) are not related between them
-   The function will give guidance every 2 seconds, once the function will work with follower1, and the next second will work with follower2, therefore the function(s) won't work with the same input
-   It is desirable that there will be some kind of coordination between both commands so that one follower will complement the other


```{r}


CalculateNextLocation3 = function(TargetCurrentLocation, OtherFollowerCurrentLocation, FollowerCurrentLocation)
{
  return (FollowerNextLocation)
}


```







